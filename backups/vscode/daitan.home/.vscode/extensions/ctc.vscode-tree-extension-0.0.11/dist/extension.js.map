{"version":3,"file":"extension.js","mappings":"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","sources":[".././src/providers/completionItemsProvider.ts",".././src/providers/foldingRangeProvider.ts",".././src/providers/formattingEditProvider.ts",".././src/providers/textDocumentChangeProvider.ts",".././src/tree.ts","../external commonjs \"vscode\"","../external node-commonjs \"path\"","../webpack/bootstrap",".././src/extension.ts"],"sourcesContent":["\nimport * as vscode from \"vscode\";\n\n// This is how we can provide intellisense/autocomplete\n\nexport function provideCompletionItems(\n  document: vscode.TextDocument,\n  position: vscode.Position,\n  token: vscode.CancellationToken\n): Promise<vscode.CompletionItem[]> {\n  const items: Array<vscode.CompletionItem> = [];\n\n  // items.push(new vscode.CompletionItem(\"├──\", vscode.CompletionItemKind.Text));\n  return Promise.resolve(items);\n}\n","import * as vscode from \"vscode\";\nimport { INDEX_NAME, treeStringToJson } from \"../tree\";\nimport { TreeType } from \"../types/treeType\";\n\nexport function provideFoldingRanges(document: vscode.TextDocument): vscode.ProviderResult<vscode.FoldingRange[]> {\n  const getLastNode = (branch: TreeType) => {\n    const indexes: Array<number> = [];\n    // Get the last line number that is a child of the given branch\n    const getIndexes = (branch: TreeType) => {\n      if (Object.values(branch).length === 1) {\n        indexes.push(branch[INDEX_NAME]);\n      } else {\n        Object.values(branch).forEach((child) => {\n          getIndexes(child);\n        });\n      }\n    };\n    getIndexes(branch);\n    return Math.max(...indexes);\n  };\n\n  const ranges = new Array<vscode.FoldingRange>();\n  const getRanges = (branch: TreeType) => {\n    const children = Object.values(branch);\n    // Each branch stores its line index in addition to children, so if there is only 1 child it is the branch's index\n    if (children.length == 1) return;\n    const startIndex = branch[INDEX_NAME];\n    const endIndex = getLastNode(branch);\n    ranges.push(new vscode.FoldingRange(startIndex, endIndex, vscode.FoldingRangeKind.Region));\n    children.forEach((child) => {\n      // The child is either the branch's line index or an Object with more children to parse\n      if (typeof child === \"number\") return;\n      getRanges(child);\n    });\n  };\n\n  const tree: TreeType = treeStringToJson(document.getText());\n  if (!tree) return ranges;\n  Object.values(tree).forEach((branch: TreeType) => {\n    getRanges(branch);\n  });\n\n  return ranges;\n}\n","\nimport * as vscode from \"vscode\";\n\n// This is for formatting the code\nexport function provideDocumentFormattingEdits(document: vscode.TextDocument): vscode.TextEdit[] {\n  const textEdits: vscode.TextEdit[] = [];\n\n  return textEdits;\n}\n","import * as vscode from \"vscode\";\n\nconst TREE_CHARS = [\"├──\", \"└──\"];\n\n// TODO: This is getting rekt by the setting: workbench.editor.languageDetection being true\nexport function textDocumentChangeProvider(event: vscode.TextDocumentChangeEvent) {\n  const { isUntitled, version } = event.document;\n  const isFirstPaste = isUntitled && version <= 2;\n\n  // console.log(\"isFirstPaste\", isFirstPaste, \"isUitite;d\", isUntitled, \"version\", version);\n  if (!isFirstPaste) {\n    return;\n  }\n\n  const textDocument = event.document;\n  const text = textDocument.getText();\n\n  // test if the doc has any tree chars\n  if (TREE_CHARS.some((v: string) => text.includes(v))) {\n    console.log(\"Containers tree char, setting lang\");\n    vscode.languages.setTextDocumentLanguage(textDocument, \"tree\");\n  }\n}\n","import { TreeType } from \"./types/treeType\";\n\nexport const uuid = () => {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16) | 0,\n      v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n};\n\n\nexport const INDEX_NAME = uuid();\n\n// Use a unique index so that it won't conflict with any file names\nconst EOL_MATCH = /\\r?\\n/;\n\n/**\n * Scans a line of text for tab chars\n * @param line\n * @returns Number of tabs in the line\n */\nconst getNumberOfTabs = (line: string): number => {\n  return (line.match(/\\t/g) || []).length;\n};\n\n/**\n * Get's the tab char based on the first child tree item\n * @param text\n * @returns A character that represents the tab char\n */\nconst getTabChar = (text: string): string | null => {\n  // Search for the first child in the tree and extract the tab character from there\n  const treeLines = text.split(EOL_MATCH);\n  const childRegex = /│?(.+)(├──|└──)/;\n  const firstChild = treeLines.find((line) => line.match(childRegex));\n  const match = firstChild?.match(childRegex);\n  return match?.[1] || null;\n};\n\n/**\n * Converts a tree string output to a json object\n * @param {String} text\n * @returns JSON object representing the tree\n */\nexport const treeStringToJson = (text: string) => {\n  const elements = new Set();\n  let prevLine = \"\";\n  const path: string[] = [];\n\n  const tabChar = getTabChar(text);\n  if (!tabChar) {\n    console.error(\"Unable to parse tab character\");\n    return {};\n  }\n\n  // replace whatever tabChar is used with \\t in memory to make parsing easier\n  const treeFormatted = text.replace(new RegExp(tabChar, \"g\"), \"\\t\");\n\n  // look for line breaks that works on all platforms\n  treeFormatted.split(EOL_MATCH).forEach((line, index) => {\n    const isTreeFormat = line.match(/^(\\t+)?(│|├──|└──|\\t)+ .+/);\n    if (!isTreeFormat) return {};\n    const prevPrefix = prevLine.split(\" \")[0];\n    const prevNumTabs = getNumberOfTabs(prevPrefix);\n    const prefix = line.split(\" \")[0];\n    const numTabs = getNumberOfTabs(prefix);\n    const filename: string = line.substr(prefix.length).trim();\n    // Pop a certain number of elements from path\n    const popCount = numTabs <= prevNumTabs ? prevNumTabs - numTabs + 1 : 0;\n    Array(popCount)\n      .fill(\"pop\")\n      .forEach(() => path.pop());\n\n    /* \n      EXAMPLE OF REDUCER FUNCTION\n        For each element in path, return elements[pathItem]\n        The result is the branch in elements for the current path\n        path = [ \"src/\", \"Home/\"]\n        elements = { \n          \"src/\": { \n            \"Home/\": {} \n          }\n        }\n        iter1 = elements[\"src/\"]\n        iter2 = elements[\"src/\"][\"Home/\"]\n        curr = {}\n    */\n    const current: TreeType = path.reduce((branch: TreeType, filename: string) => branch[filename], elements);\n    current[filename] = { [INDEX_NAME]: index };\n    prevLine = line;\n    path.push(filename);\n  });\n  return elements;\n};\n","module.exports = require(\"vscode\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import * as vscode from \"vscode\";\nimport * as path from \"path\";\n\nimport { provideFoldingRanges } from \"./providers/foldingRangeProvider\";\nimport { provideDocumentFormattingEdits } from \"./providers/formattingEditProvider\";\nimport { provideCompletionItems } from \"./providers/completionItemsProvider\";\nimport { textDocumentChangeProvider } from \"./providers/textDocumentChangeProvider\";\n\nconst { VSCODE_DEBUG = false } = process.env;\n\n// when the extension is activated\nexport async function activate(context: vscode.ExtensionContext) {\n  context.subscriptions.push(\n    vscode.languages.registerFoldingRangeProvider({ language: \"tree\" }, { provideFoldingRanges })\n  );\n\n  context.subscriptions.push(\n    vscode.languages.registerDocumentFormattingEditProvider({ language: \"tree\" }, { provideDocumentFormattingEdits })\n  );\n\n  context.subscriptions.push(\n    vscode.languages.registerCompletionItemProvider({ language: \"tree\" }, { provideCompletionItems }, \"|\")\n  );\n\n  vscode.workspace.onDidChangeTextDocument(textDocumentChangeProvider);\n\n  // Open example.tree in a new window when running locally for debugging\n  if (VSCODE_DEBUG) {\n    const fileUrl = path.join(context.extensionPath, \"src/__tests__/trees/tab-lf.tree\");\n    const document = await vscode.workspace.openTextDocument(fileUrl);\n    vscode.window.showTextDocument(document);\n  }\n}\n"],"names":["document","position","token","Promise","resolve","ranges","Array","getRanges","branch","children","Object","values","length","startIndex","INDEX_NAME","endIndex","indexes","getIndexes","push","forEach","child","Math","max","getLastNode","vscode","FoldingRange","FoldingRangeKind","Region","tree","treeStringToJson","getText","TREE_CHARS","event","isUntitled","version","textDocument","text","some","v","includes","console","log","languages","setTextDocumentLanguage","uuid","replace","c","r","random","toString","EOL_MATCH","getNumberOfTabs","line","match","elements","Set","prevLine","path","tabChar","treeLines","split","childRegex","firstChild","find","getTabChar","RegExp","index","prevPrefix","prevNumTabs","prefix","numTabs","filename","substr","trim","fill","pop","current","reduce","error","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","VSCODE_DEBUG","process","env","async","context","subscriptions","registerFoldingRangeProvider","language","provideFoldingRanges","registerDocumentFormattingEditProvider","provideDocumentFormattingEdits","registerCompletionItemProvider","provideCompletionItems","workspace","onDidChangeTextDocument","textDocumentChangeProvider","fileUrl","join","extensionPath","openTextDocument","window","showTextDocument"],"sourceRoot":""}